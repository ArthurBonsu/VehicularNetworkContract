// SPDX-License-Identifier: LGPL-3.0-only


pragma solidity 0.8.2;


contract VehicleContract 
 {

   address public gnosissafeownerhere;

   
         
        struct Vehicle {      
        address  vehicleaddress;  
        string  vehiclename;
        string  cartype;
        uint256  proposalindex;
        string pseudorandomnum;
        bool active;      
      }
         

   
      Vehicle vehiclenode;
      Vehicle[] public vehiclestore;
    //  string [][] public multiwalletlist ;
    //  string[] public safeaddressarray;


mapping(address => address) public registeredentitiesasddress;
mapping(address =>  string ) public  registeredentitiespseudonymlist;
mapping(address =>  string ) public  revokedlist;
mapping(address =>  string ) public  prevrevokedlist;
 mapping(address => Vehicle) public vehiclelist;


event registrationevent(address indexed vehicleaddress, string indexed  vehiclename, string indexed  cartype);

event GetVehicleDetailViaAddressEvent(address indexed _myvehicleaddress,   string indexed myvehiclename, string indexed mycartype, uint256  indexed proposalindex, string indexed pseudorandomnum,  string indexed active );
event GetVehicleDetailViaPseudonymnEvent(address indexed _myvehicleaddress,   string indexed myvehiclename, string indexed mycartype, uint256  indexed proposalindex, string indexed pseudorandomnum,  string indexed active);
event GetAllAddressesEvent(address[] indexed vehicleaddresses);



    function Registration (address _vehicleaddress, string _vehiclename, string _cartype ) external returns (address _thevehicleaddress, string memory fibonaccistring  ) {
      uint256 index=0;
      
      // We set it amoong the registered hashmaps
      registeredentitiesasddress[_vehicleaddress]=_vehicleaddress;
     
     // We design a fabonacci algorithm to create a pseudonym
     bytes memory fibonacci = abi.encodePacked(_vehicleaddress);
     string memory fibonaccistring = bytesToString(fibonacci);
   
    // multiwalletlist.push ([addressstring,safestring]);
 

   //  listofownersafe = OwnerSafeHere(walletaddress,safestring );
      // We store the vehicle nodes on the blockchain and set it as registered with details
     vehiclestore.push(_vehicleaddress);
     vehiclestore[_vehicleaddress].vehicleaddress=_vehicleaddress;
     vehiclestore[_vehicleaddress].vehiclename=_vehiclename;
     vehiclestore[_vehicleaddress].cartype=_cartype;
     vehiclestore[_vehicleaddress].pseudorandomnum=fibonaccistring;
     vehiclestore[_vehicleaddress].active= true;
    
    // We store the pseudorandom value as well
    registeredentitiespseudonymlist[_vehicleaddress] = fibonaccistring;
      

      // Events logged on the blockchain
      emit registrationevent( _vehicleaddress,   _vehiclename,   _vehiclename  );
     // We increase the number of vehicles registered count
      index++;
      
    return (_vehicleaddress,fibonaccistring);
   
   
    }

function GetVehicleDetailViaAddress  (address _vehicleaddress) external returns ( address _myvehicleaddress,   string myvehiclename, string mycartype, uint256  proposalindex, string pseudorandomnum,  string active ) {
 
       require (registeredentitiesasddress[_vehicleaddress]==_vehicleaddress,  "Address is not registered, try registering");
   
   address myvehicleaddress = vehiclestore[_vehicleaddress].vehicleaddress;
    string myvehiclename = vehiclestore[_vehicleaddress].vehiclename;
    string mycartype = vehiclestore[_vehicleaddress].cartype;
     uint256  proposalindex=  vehiclestore[_vehicleaddress].proposalindex;
    string pseudorandomnum= vehiclestore[_vehicleaddress].pseudorandomnum;
  
    string active= vehiclestore[_vehicleaddress].active;

      emit GetVehicleDetailViaAddressEvent(myvehicleaddress,myvehiclename,mycartype, proposalindex, pseudorandomnum,active);
 
      
    return (myvehicleaddress,myvehiclename,mycartype, proposalindex, pseudorandomnum,active);
   
   
    }
function GetVehicleDetailViaPseudonymn  (address _vehicleaddreess, address _pseudorandomnum) external returns ( address _myvehicleaddress,   string myvehiclename, string mycartype, uint256  proposalindex, string pseudorandomnum,  string active  ) {
  
               require (registeredentitiespseudonymlist[_vehicleaddreess]==_pseudorandomnum,  "Address is not registered, try registering");
   
   address myvehicleaddress = vehiclestore[_vehicleaddress].vehicleaddress;
    string myvehiclename = vehiclestore[_vehicleaddress].vehiclename;
    string mycartype = vehiclestore[_vehicleaddress].cartype;
     uint256  proposalindex=  vehiclestore[_vehicleaddress].proposalindex;
    string pseudorandomnum= vehiclestore[_vehicleaddress].pseudorandomnum;
  
    string active= vehiclestore[_vehicleaddress].active;

      emit GetVehicleDetailViaPseudonymnEvent(myvehicleaddress,myvehiclename,mycartype, proposalindex, pseudorandomnum,active);
 
      
    return (myvehicleaddress,myvehiclename,mycartype, proposalindex, pseudorandomnum,active);
 
  
   
   
    }

function GetAllRegisteredAddress () external returns (address[] vehicleaddresses) {
   address[] alladdresses =  registeredentitiesasddress;

             
      emit GetAllAddressesEvent(alladdresses);
 
      
    return (alladdresses);
 
  
   
   
    }
function GetAllPseudonymAddress () external returns (address[] vehicleaddresses) {
   address[] pseudonym =  registeredentitiesasddress;

             
      emit GetAllPseudonymEvent(alladdresses);
 
      
    return (alladdresses);
 
     }

//Revoke
//

function CheckIfVehicleExistsViaAddress  (address _vehicleaddreess) external returns (bool existent ) {
      require (registeredentitiesasddress[_vehicleaddreess]==_vehicleaddreess,  "Address is not registered, try registering");
    bool  _existent = true;   
      
    return (_existent);
   
   
    }
function CheckIfVehicleExistsViaPseudonym  (string _pseudorandomnum) external returns (bool existent ) {
      require (registeredentitiespseudonymlist[_vehicleaddreess]==_pseudorandomnum,  "Address is not registered, try registering");
    bool  _existent = true;   
      
    return (_existent);
   
   
    }

}
